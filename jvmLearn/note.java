package jvmLearn;

public class note {
}
//把编译好的class文件放在虚拟机上执行，而不是硬件
//在硬件和二进制文件之间加入虚拟机层的做法
//虚拟机的具体实现可能有差别，但遵循一套抽象的规则，即Java虚拟机规范
//令实现者可以在保持程序语义不变的前提下，获得充分的发挥空间。
//Scala写的程序也可以运行在jvm上，还是程序设计领域的一种思维方式
//jvm的实现必须体现jvm规范的内容，仅在却有必要时，才受制于这些规范。
//为了尽量保持二进制兼容性，Java SE 8 应该直接在Java虚拟机里指定带有默认实现代码的default方法，而不依赖于编译器。

// 引言 java是通用的、面向对象的、支持并发的程序语言。隐藏了c和c++中许多复杂、深奥、不安全的语言特性
//Java虚拟机是整个Java平台的基石，是Java技术用以实现硬件无关与操作系统无关的关键部分。是Java语言生成出极小体积的编译代码的运行平台，是保障用户机器免于恶意代码损害的屏障。
//Java虚拟机可以看作一台抽象的计算机，有自己的指令集及各种运行时内存区域。
//JVM并不局限于特定的实现技术，主机硬件和操作系统，也不强求使用解释器来执行程序，可以通过把自己的指令集编译为实际CPU的指令来实现，可以通过微代码来实现，甚至直接在CPU中实现。
// Java虚拟机和Java语言没有必然的联系，只与特定的二进制文件格式 class文件格式管理安。class文件包含了指令集和符号表，以及其他辅助信息。
//基于安全考虑，JVM在class文件中施加了许多强制性的语法和结构化约束，凡是能用class文件正确表达的编程语言，都可以放在java虚拟机里执行。

// 内容
// java虚拟机整体架构 如何将java语言编写的程序，转换为Java虚拟机指令集 定义class文件的格式，用来表示编译后的类和接口
// Java虚拟机启动以及类和接口的加载、链接、初始化过程 Java虚拟机指令集，并完整这些指令的指令助记符表示他们。
// 以操作码值为索引的Java虚拟机操作码助记表。

//java虚拟机结构
// 规范描述的是一种抽象化的虚拟机的行为，而不是任何一种广泛使用的虚拟机实现
//"正确地"实现一台java虚拟机，只需要正确读取class文件的每一条字节码指令，并且能正确执行这些指令蕴含的操作。
//class文件格式：二进制格式，经常以文件的形式存储（也可能不是），class文件格式中精确定义了类和接口的表示形式和细节。
// 数据类型：两类，原始类型（基本类型）和引用类型。对应的数据分别为 原始值 和引用值。可以用于变量赋值、参数传递、方法返回和运算操作。
// 编译器应当在编译期间尽最大努力完成可能的类型检查
//java虚拟机是直接支持对象的，这里的对象指动态分配的某个类的实例，也可以指某个数组。
//虚拟机使用reference类型来表示某个对象的引用。每个对象都可能存在多个指向它的引用，对象的操作、传递和检查都通过引用它的refrence类型的数据来进行。

// 原始类型与值
//Java虚拟机支持的原始类型包括 数值类型，boolean类型和 returnAddress类型 三类。
//数值类型分为 整数类型和浮点类型 两种
// 整数类型 规定了整数类型的取值范围 byte 8位有符号二进制补码整数，默认值为0 ，类似的 short，int，long char 16位无符号整数表示的Unicode码点 默认值为 \u0000
// 浮点类型 float 但精度浮点数集合，或单精度扩展指数集合 类似 double （在第二版中开始作为原始类型）
// 虚拟机必须支持两种标准的浮点值集合，可以自由选择实现是否要支持扩展指数集合的一种或者全部。
// 每一种扩展指数集合都有比标准浮点数集合更大的指数取值范围，但不会有更高的精度
// 规定了NaN是无序的，与任何数值比较==都会返回false，比较！=都会返回true，与自身比较==也会返回false
// 浮点数除了NaN都是有序的：负无穷，可数负数，正负0，可数整数，正无穷。
// returnAddress 类型是指向某个操作码的指针，此操作码与虚拟机指令相对应。
//returnAddress 类型会被jsr，ret 和jsr_w指令所使用，无法在程序运行期间修改（JDK7 时，returnAddress被冗余finally块代码取代，名存实亡）
// boolean类型 只对它实现非常有限的支持

//引用类型与值
// JVM有三种引用类型： 类类型，数组类型 和接口类型 分别指向：动态创建的类实例，数组实例，和实现了某个接口的类实例和数组实例
//数组类型最外面的一维元素类型，叫做该数组类型的组建类型。数组的组件类型也可以是数组。最终取到的不是数组的组件类型，称为本数组类型的元素类型，数组的元素类型必须是原生类型，类类型或接口类型。
//引用类型的特殊值null，可以转化为任意的引用类型。当引用不指向任何对象时，用null表示。

//运行时数据区
//JVM定义了若干种程序运行期间会使用到的运行时数据区，有些随着虚拟机启动而创建，随虚拟机退出而销毁，另一些与线程一一对应，随着线程开始和结束而创建和销毁。
//pc寄存器
//多条线程同时执行时，每一条线程有自己的pc寄存器（program counter）。任意时刻，一条Java虚拟机线程只会执行一个方法的代码，称为该线程的当前方法。
//如果方法不是native的，pc寄存器就保存在java虚拟机正在执行的字节码指令的地址。
//如果方法是native的，pc寄存器的值是undefined，pc寄存器的容量至少应当能保存一个returnAddress类型的数据或者一个与平台相关的本地指针
//Java虚拟机栈
//每一条Java虚拟机线程都有自己私有的Java虚拟机栈，与线程同时创建，用于存储栈帧。除了用于存储局部变量和一些尚未算好的结果，在方法调用和返回中，也有使用。
//除了出栈和入栈外，java虚拟机栈不会受其他因素的影响，栈帧可以在堆中分配，所需要的内存不需要保证是连续的。
//jvm规范允许java虚拟机栈被实现成固定大小（在线程创建时独立选定），也允许根据计算动态来扩展和收缩。
//jvm实现应当提供给程序员或最终用户调节虚拟机栈初始化容量的手段。对于可以动态扩展和收缩Java虚拟机栈，应当提供调节起最大、最小容量的手段。
//java虚拟机栈可能发生的异常情况
// 线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，会抛出StackOverflowError异常。
//如果虚拟机栈可以动态扩展，尝试扩展的时候无法申请到足够的内存，或创建新的线程时，没有足够的内存去创建对应的虚拟机栈，会抛出OutOfMemoryError异常。
//Java堆
//

